/* this source code form is subject to the terms of the mozilla public
 * license, v. 2.0. if a copy of the mpl was not distributed with this
 * file, you can obtain one at http://mozilla.org/mpl/2.0/. */

define((require, exports, module) => {
"use strict";

const {Class} = require('lang/class');
const {Component, createElement} = require("react");

const isPreMountHook = field => field && field.mount;
exports.isPreMountHook = isPreMountHook;

const isPostMountHook = field => field && field.mounted;
exports.isPostMountHook = isPostMountHook;

const isUpdateHook = field => field && field.write;
exports.isUpdateHook = isUpdateHook;

const isConstractorHook = field => field && field.construct;
exports.isConstractorHook = isConstractorHook;

const isHook = field => field && field.isHook;

// This is a helper class that can be used to create components
// for rendering HTML elements that are not recognized by react.
// Subclass must implement `tagName` string field and provide set
// of hooks that will be triggered by a props changes. This allows
// mapping options passed to attributes, event listeners and even
// making thigs like focus or selection declarative.
const Element = Class.extends(Component, {
  get tagName() {
    throw TypeError("Subclass of Element should implement tagName field");
  },
  get displayName() {
    return `<html:${this.tagName}\>`
  },
  constructor(...args) {
    Element.initialize(this);
    Component.call(this, ...args);
  },
  componentDidMount() {
    return Element.componentDidMount(this);
  },
  componentDidUpdate(past) {
    return Element.componentDidUpdate(this, past);
  },
  render() {
    return Element.render(this);
  },
});
exports.Element = Element;

Element.initialize = component => {
  const mountHooks = [];
  const mountedHooks = [];
  const updateHooks = [];
  const hooks = {};

  for (let key in component) {
    const field = component[key];
    if (isHook(field)) {
      const hook = field.construct();
      hooks[key] = hook;

      if (isPreMountHook(hook)) {
        mountHooks.push(key);
      }
      if (isPostMountHook(hook)) {
        mountedHooks.push(key);
      }
      if (isUpdateHook(hook)) {
        updateHooks.push(name);
      }
    }
  }

  component.state = {hooks, mountHooks, mountedHooks, updateHooks};
};

// Sets custom attributes declared but not recognized by react manually.
Element.componentDidMount = component => {
  const node = component.getDOMNode();
  const present = component.props;
  const {hooks, mountHooks, mountedHooks} = component.state;

  if (mountHooks.length > 0) {
    mountHooks.forEach(name => {
      const hook = hooks[name];
      const value = present[name];
      hook.mount(node, value);
    });

    // Pre mount fields need to be set before node
    // is in the document. Since react does not has
    // an appropriate hook we replace node with itself
    // to trigger desired behavior.
    node.parentNode.replaceChild(node, node);
  }

  mountedHooks.forEach(name => {
    const hook = hooks[name];
    hook.mounted(node, present[name]);
  });
};

Element.componentDidUpdate = (component, past) => {
  const node = component.getDOMNode();
  const present = component.props;
  const {hooks, updateHooks} = component.state;

  updateHooks.forEach(name => {
    const hook = hooks[name];
    hook.write(node, present[name], past[name]);
  });
};

// Render renders wrapped HTML node.
Element.render = component =>
createElement(component.tagName,
              component.props,
              component.props.children);


const Hook = Class({
  construct() {
    return this;
  },
  isHook: true
});

// Option can be used to define attribute on the element
// that is set once before element is inserted into a
// document (mounted). Changes to this option are ignored
// & in general use of `Attribute` is preferred, this should
// be reserved only for attributes changes to which aren't picked
// up after node is in the tree.
// Example: Element("iframe", { browser: Option("mozbrowser") })
const Option = Class.extends(Hook, {
  constructor(name) {
    if (!(this instanceof Option)) {
      return new Option(name);
    }

    this.name = name;
  },
  mount(node, value) {
    node.setAttribute(this.name, value);
  }
});
exports.Option = Option;

// Attribute can be used to define field mapped to a
// DOM attribute with a given `name`. If the field is
// set to `undefined` or `null` attribute is removed
// othrewise it's set to given value.
// Example: Element("hbox", {flex: Attribute("flex")})
const Attribute = Class.extends(Hook, {
  constructor(name) {
    if (!(this instanceof Attribute)) {
      return new Attribute(name);
    }

    this.name = name;
  },
  mounted(node, value) {
    if (value != void(0)) {
      node.setAttribute(this.name, value);
    }
  },
  write(node, present, past) {
    if (present != past) {
      if (present == void(0)) {
        node.removeAttribute(this.name);
      }
      else {
        node.setAttribute(this.name, present);
      }
    }
  }
});
exports.Attribute = Attribute;

// Field can be used to define fields that can't be
// mapped to an attribute in the DOM. Field is defined
// by providing a function that will be invoked target
// `node` `current` value & `past` value and it's supposed
// to reflect changes in the DOM. Note that on initial
// render `past` will be `void(0)`.
//
// Example:
// Class.extends(Element, {
//   tagName: "iframe",
//   isFocused: new Field((node, current, past) => {
//     if (current) {
//       node.focus()
//     }
//   })
// })
const Field = Class.extends(Hook, {
  constructor(write) {
    if (!(this instanceof Field)) {
      return new Field(write);
    }
    this.write = write;
  },
  mounted(node, value) {
    this.write(node, value, void(0));
  }
});
exports.Field = Field;

// Event can be used to define event handler fields, for
// the given event `type`. When event of that type occurs
// event handler assigned to the associated field will be
// invoked. Optionally `read` function can be passed as a
// second argument, in which case event handler will be
// invoked with `read(event)` instead of `event`.
// Example:
// Class.extends(Element, {
//   tagName: "iframe",
//   onTitleChange: new Event("mozbrowsertitlechange")
// })
const Event = Class.extends(Hook, {
  constructor(type, read, capture=false) {
    if (!(this instanceof Event)) {
      return new Event(type, read, capture);
    }

    this.type = type;
    this.read = read;
    this.capture = capture;
  },
  construct() {
    return new this.constructor(this.type, this.read, this.capture);
  },
  capture: false,
  mounted(node, handler) {
    this.handler = handler;
    node.addEventListener(this.type, this, this.capture);
  },
  write(node, present) {
    this.handler = present;
  },
  handleEvent(event) {
    if (this.handler) {
      this.handler(this.read ? this.read(event) : event);
    }
  }
});
exports.Event = Event;

// CapturedEvent can be used same as `Event` with a difference
// that events listeners will be added with a capture `true`.
const CapturedEvent = Class.extends(Event, {
  constructor(type, read) {
    if (!(this instanceof CapturedEvent)) {
      return new CapturedEvent(type, read);
    }
    Event.call(this, type, read, true);
  }
});
exports.CapturedEvent = CapturedEvent;

});
