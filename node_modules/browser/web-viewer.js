/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

define((require, exports, module) => {

'use strict';

const {DOM} = require('react');
const {Map} = require('immutable');
const {isFocused} = require('./focusable');
const {Element, Option, Field, Event} = require('./element');
const Component = require('omniscient');
const {Deck} = require('./deck');

const IFrame = Element('iframe', {
  isFocused: isFocused,
  isRemote: new Option('remote'),
  isBrowser: new Option('mozbrowser'),
  allowFullScreen: new Option('mozallowfullscreen'),
  src: Field((node, current, past) => {
    if (current != past) {
      if (node.setVisible) {
        node.src = current;
      } else {
        node.src = `data:text/html,${current}`
      }
    }
  }),
  isVisible: Field((node, current, past) => {
    if (current != past) {
      if (node.setVisible) {
        node.setVisible(current);
      }
    }
  }),
  zoom: Field((node, current, past) => {
    if (current != past) {
      if (node.zoom) {
        node.zoom(current);
      }
    }
  }),
  readyState: Field((node, current, past) => {
    if (current == 'reload') {
      if (node.reload) {
        node.reload();
      }
    }

    if (current == 'stop') {
      if (node.stop) {
        node.stop();
      }
    }

    if (current == 'goBack') {
      if (node.goBack) {
        node.goBack();
      }
    }

    if (current == 'goForward') {
      if (node.goForward) {
        node.goForward();
      }
    }

    if (current == 'loading') {
      if (node.getCanGoBack) {
        node.getCanGoBack().onsuccess = IFrame.onCanGoBackChange(node)
      }
      if (node.getCanGoForward) {
        node.getCanGoForward().onsuccess = IFrame.onCanGoForwardChange(node)
      }
    }
  }),
  onAsyncScroll: Event('mozbrowserasyncscroll'),
  onClose: Event('mozbrowserclose'),
  onOpenWindow: Event('mozbrowseropenwindow'),
  onContextMenu: Event('mozbrowsercontextmenu'),
  onError: Event('mozbrowsererror'),
  onLoadStart: Event('mozbrowserloadstart'),
  onLoadEnd: Event('mozbrowserloadend'),
  onIconChange: Event('mozbrowsericonchange'),
  onUserActivityDone: Event('mozbrowseractivitydone'),
  onVisibilityChange: Event('mozbrowservisibilitychange'),
  onMetaChange: Event('mozbrowsermetachange'),
  onLocationChange: Event('mozbrowserlocationchange'),
  onSecurityChange: Event('mozbrowsersecuritychange'),
  onTitleChange: Event('mozbrowsertitlechange'),
  onPrompt: Event('mozbrowsershowmodalprompt'),
  onAuthentificate: Event('mozbrowserusernameandpasswordrequired'),
  onCanGoBackChange: Event('mozbrowsercangobackchange'),
  onCanGoForwardChange: Event('mozbrowsercangoforwardchange')
});

IFrame.onCanGoBackChange = node => request =>
  node.dispatchEvent(new CustomEvent('mozbrowsercangobackchange',{
    'detail': request.target.result
  }));

IFrame.onCanGoForwardChange = node => request =>
  node.dispatchEvent(new CustomEvent('mozbrowsercangoforwardchange',{
    'detail': request.target.result
  }));


const WebViewer = Component(({item, removeItem}) => IFrame({
  className: 'frame flex-1 webviwer',
  key: `frame-${item.get('id')}`,
  isBrowser: true,
  isRemote: true,
  allowFullScreen: true,

  isVisible: item.get('isSelected'),
  hidden: !item.get('isSelected'),
  zoom: item.get('zoom'),
  isFocused: item.get('isFocused'),
  src: item.get('uri'),

  onCanGoBackChange: WebViewer.onCanGoBackChange(item),
  onCanGoForwardChange: WebViewer.onCanGoForwardChange(item),
  onBlur: WebViewer.onBlur(item),
  onFocus: WebViewer.onFocus(item),
  onAsyncScroll: WebViewer.onUnhandled,
  onClose: event => removeItem(item.get('id')),
  onOpenWindow: WebViewer.onUnhandled,
  onContextMenu: WebViewer.onUnhandled,
  onError: event => console.error(event),
  onLoadStart: WebViewer.onLoadStart(item),
  onLoadEnd: WebViewer.onLoadEnd(item),
  onMetaChange: WebViewer.onMetaChange(item),
  onIconChange: WebViewer.onIconChange(item),
  onLocationChange: WebViewer.onLocationChange(item),
  onSecurityChange: WebViewer.onSecurityChange(item),
  onTitleChange: WebViewer.onTitleChange(item),
  onPrompt: WebViewer.onPrompt(item),
  onAuthentificate: WebViewer.onAuthentificate(item)
}));

WebViewer.onUnhandled = event => console.log(event)
WebViewer.onBlur = state => event => state.set('isFocused', false);

WebViewer.onFocus = state => event => state.set('isFocused', true);

WebViewer.onLoadStart = state => event => state.merge({
  readState: 'loading',
  loading: true,
  icons: null,
  title: null,
  location: null,
  backgroundColor: null,
  securityState: 'insecure',
  securityExtendedValidation: false,
  canGoBack: false,
  canGoForward: false
});

WebViewer.onLoadEnd = state => event => state.merge({
  readState: 'loaded',
  loading: false,
  backgroundColor: event.detail.backgroundColor
});

WebViewer.onTitleChange = state => event => state.set('title', event.detail);

WebViewer.onLocationChange = state => event => state.set('location', event.detail);

WebViewer.onIconChange = state => event =>
  state.set(['icons', event.detail.href], event.detail);

WebViewer.onMetaChange = state => event =>
  state.set('metadata', event.detail);

WebViewer.onCanGoBackChange = state => event =>
  state.set('canGoBack', event.target.result);

WebViewer.onCanGoForwardChange = state => event =>
  state.set('canGoForward', event.target.result);

WebViewer.onPrompt = state => event => console.log(event);

WebViewer.onAuthentificate = state => event => console.log(event);

WebViewer.onSecurityChange = state => event =>
  state.merge({securityState: event.detail.state,
               securityExtendedValidation: event.detail.extendedValidation});

WebViewer.initial = new Map({
  zoom: 1,
  readState: null,
  loading: false,
  focused: false,
  input: null,
  uri: null,
  location: null,
  title: null,
  icons: new Map(),
  meta: null,
  backgroundColor: null,
  securityState: 'insecure',
  securityExtendedValidation: false,
  canGoBack: false,
  canGoForward: false
});

WebViewer.reload = state => state.set('readyState', 'reload');
WebViewer.stop = state => state.set('readState', 'stop');
WebViewer.goBack = state => state.set('readyState', 'goBack');
WebViewer.goForward = state => state.set('readState', 'goForward');

exports.WebViewer = WebViewer;


const WebDeck = Deck(WebViewer);
WebDeck.reload = Deck.edit(WebViewer.reload, Deck.isSelected);
WebDeck.stop = Deck.edit(WebViewer.stop, Deck.isSelected);
WebDeck.goBack = Deck.edit(WebViewer.goBack, Deck.isSelected);
WebDeck.goForward = Deck.edit(WebViewer.goForward, Deck.isSelected);
WebDeck.selected = Deck.selected;
WebDeck.selectedIndex = Deck.selectedIndex;
exports.Deck = WebDeck;

});
