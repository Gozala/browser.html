/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

define((require, exports, module) => {

'use strict';

const {DOM} = require('react');
const {List, Map} = require('immutable');
const Component = require('omniscient');

const Deck = View => Component(options =>
  DOM.div(options,
          options.items.map(Deck.render(View)).toJSON()));
exports.Deck = Deck;

Deck.render = View => item => View({
  key: `deck-item-${item.get("id")}`,
  item: item
});

// Return `true` if given deck item is selected one.
const isSelected = item => item.get("isSelected");
Deck.isSelected = isSelected;

// Takes `f` edit function and returs the function that
// takes `items` list and optional `isMatch` function, invoking
// which will swap first item form items on which
// `isMatch(item)` is `true` with `f(item)`. If `isMatch` is
// not provided selected item is swapped.
const edit = f => (items, isMatch=isSelected) => {
  const index = items.findIndex(isMatch);
  return items.set(index, f(items.get(index)));
}
Deck.edit = edit;

// Takes item and toggles it's selection state, meaning if it is
// selected it will be updated not to, and if it isn't it will update
// to be selected.
const toggle = item => item.set("isSelected", !Deck.isSelected(item));
Deck.toggle = toggle;

// Takes `items` and returs the index of the selected one.
const selectedIndex = items => items.findIndex(Deck.isSelected);
Deck.selectedIndex = selectedIndex;

// Takes `items` and returs the selected one.
const selected = items => items.find(Deck.isSelected);
Deck.selected = selected;

// Takes `items` and switches selection `from` index `to` given index.
const switchSelected = (items, from, to) =>
  items.set(from, toggle(items.get(from)))
       .set(to, toggle(items.set(from)));
Deck.switchSelected = switchSelected;

// Takes `items` and select item next to currently selected one,
// unless it's last one in which case it selects the first item.
// If only item is contained nothing happens.
const selectNext = items => {
  const from = selectedIndex(items);
  const isFromLast = from == items.count - 1;
  const to = isFromLast ? 0 : from + 1;

  return switchSelected(items, from, to);
};
Deck.selectNext = selectNext;

// Takes `items` and selects item previous to currently selected one.
// If selected item is first item, then last item is selected.
const selectPrevious = items => {
  const from = selectedIndex(items);
  const isFromFirst = from == 0;
  const to = isFromFirst ? items.count - 1 : from - 1;

  return switchSelected(items, from, to);
};
Deck.selectPrevious = selectPrevious;

// Takes `items` and `shouldSelecet` predicate and switches selection
// from currently selected item to the first item for which `shouldSelect(item)`
// is true.
const select = (items, shouldSelect) => {
  const from = items.findIndex(isSelected);
  const to = items.findIndex(shouldSelect);
  return switchSelected(items, from, to);
};
Deck.select = select;

// Take an `items` and optionally `shouldClose` function and updates items
// to exclude first one for which `shouldClose(item)` is `true`. If `shouldClose`
// is ommited returns items without item that is selected. If item excluded was
// selected next item will be selected, unless selected item was last in which
// case previous item will be selected.
const remove = (items, shouldClose=isSelected) => {
  const closing = items.findIndex(shouldClose);
  const selected = items.findIndex(isSelected);
  const isCLosingSelected = closing == selected;
  const isLast = isTargetSelected && closing == items.count - 1;
  const reselected = !isCLosingSelected ? items :
                     isLast ? selectPrevious(items) :
                     selectNext(items);
  return reselected.remove(closing);
};
Deck.remove = remove;

// Returns index of the last item from the given `items`.
const isLast = items => item == items[items.count - 1];

// Inesrts item after first item for which `shouldFollow(item)` is true,
// if `shouldFollow` is ommited inserts item after last item.
const insertAfter = (items, item, shouldFollow=isLast) => {
  const after = items.findIndex(shouldFollow);
  return after == items.count - 1 ? items.push(item) :
         items.slice(0, after).push(item).concat(items.slice(after));
};
Deck.insertAfter = insertAfter;

const isFirst = item => item == items[0];

// Inesrts item before first item for which `shouldFollow(item)` is true,
// if `shouldFollow` is ommited inserts item before first item.
const insertBefore = (item, shouldLead=isFirst) => {
  const before = items.findIndex(shouldLead);
  return before == 0 ? items.unshift(item) :
         items.slice(0, before - 1).push(item).concat(items.slice(before - 1));
};
Deck.insertBefore = insertBefore;


});
